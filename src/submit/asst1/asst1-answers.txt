
Assignment 1 
Author: Carol Fu
Date: Jan.15.2016

1.What is the name of the very first function that executes when OS161 starts up? 
    -"__start"
2. What is the very first assembly instruction that executes? 
    -allocate 24-byte on the stack frame to store return address register,16 byte for making a call, and  an 8-byte (64-bit) boundary
  .frame sp, 24, $0    /* 24-byte sp-relative frame; return addr on stack */
  .mask 0x80000000, -4 /* register 31 (ra) saved at (sp+24)-4 */
   addiu sp, sp, -24
   sw ra, 20(sp)

3. Set the breakpoints in the kernel function that shows the menu and in the kernel main function. Now tell GDB to display all the breakpoints that were set and copy the output to your submit file. 
   (gdb) info breakpoints
   Num     Type           Disp Enb Address    What
   1       breakpoint     keep y   0x800139e4 in kmain at ../../main/main.c:211
   breakpoint already hit 1 time
   
   2       breakpoint     keep y   0x800139ec in kmain at ../../main/main.c:213
   breakpoint already hit 1 time


4. Briefly describe what happens between the beginning of the execution and the invocation of the kernel main function. 
   1. Execution starts in kern/arch/sys161/main/start.S file
   2. The system first allocate 24 byte on the stack frame. In which 16 byte are for function calling, 8 byte for boundary, and also for saving the return address register
   3. Set up the memory map by allocating the top of the physical memory to the first processor, and save the boot string immediately below it at register a0. Load kernel at virtual address at 0x80000200 (physical address 0x00000200).The memory blow is reserved for exception vector code.
     Next, set up a stack frame on the real kernel stack (24 byte)
     Then, copy the exception handler code onto the memory
     Next, flush contents in cache to the memory
     Then, enable master interrupt, set rest of the status registers, and load CPU number into the CONTEXT register.
     Lastly, the GP register is loaded with an address of the middle part of the data segment

5. What is the assembly language instruction that calls the kernel main function? 
     jal kmain
6. Step through the boot() code to find out what functions are called during early initialization. Paste the gdb output that shows you what these functions are.
    boot () at ../../main/main.c:99
    99      kprintf("\n");
    (gdb) n
    100     kprintf("OS/161 base system version %s\n", BASE_VERSION);
    (gdb) n
    101     kprintf("%s", harvard_copyright);
    (gdb) n
    102     kprintf("\n");
    (gdb) n
    104     kprintf("Put-your-group-name-here's system version %s (%s #%d)\n",
    (gdb) n
    106     kprintf("\n");
    (gdb) n
    109     ram_bootstrap();
    (gdb) n
    110     proc_bootstrap();
    (gdb) n
    111     thread_bootstrap();
    (gdb) n
    112     hardclock_bootstrap();
    (gdb) n
    113     vfs_bootstrap();
    (gdb) n
    114     kheap_nextgeneration();
    (gdb) n
    117     kprintf("Device probe...\n");
    (gdb) n
    118     KASSERT(curthread->t_curspl > 0);
    (gdb) n
    119     mainbus_bootstrap();
    (gdb) n
    120     KASSERT(curthread->t_curspl == 0);
    (gdb) n
    122     pseudoconfig();
    (gdb) n
    123     kprintf("\n");
    (gdb) n
    124     kheap_nextgeneration();
    (gdb) n
    127     vm_bootstrap();
    (gdb) n
    128     kprintf_bootstrap();
    (gdb) n
    129     thread_start_cpus();
    (gdb) n
    132     vfs_setbootfs("emu0");
    (gdb) n
    134     kheap_nextgeneration();
    (gdb) n
    141 }

7. Set a breakpoint in thread_bootstrap(). Once you hit that breakpoint, at the very first line of that function, attempt to print the contents of the *bootcpu variable. Copy the output into the submit file. 
    (gdb) p *bootcpu
    Cannot access memory at address 0x80000

8. Now, step through that function until after the line that says 'bootcpu = cpu_create(0)'. Now print the content of *bootcpu and paste the output. 
(gdb) s
thread_bootstrap () at ../../thread/thread.c:367
367     bootcpu = cpu_create(0);
(gdb) p *bootcpu
Cannot access memory at address 0x80000


Now let's learn how to use some of the very useful gdb macros provided with OS161. Copy the contents of kern/gdbscripts/array into your .gdbinit file. If you don't know where .gdbinit is and how to make sure that gdb accepts its commands, make sure that you mind the answer in the GDB tutorial.  Read through the macros that you just copied and find the one that helps you print the contents of the array containing all the CPUs. 

9. Print the allcpus array before the boot() function is executed. Paste the output. 
(gdb) p allcpus
$1 = {arr = {v = 0x0, num = 0, max = 0}} 

10. Print again the same array after the boot() function is executed. Paste the output.
(gdb) p allcpus
$2 = {arr = {v = 0x80039fe0, num = 1, max = 4}}


