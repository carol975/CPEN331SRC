What happens to a thread when it exits (i.e., calls thread_exit())? What about when it sleeps?
-thread_exit removes the virtual memory mapped to it. Then switch the thread to S_ZOMBIE and make the thread panics should the thread ever run again before the thread goes to S_SLEEP
-make sure the thread is not acting as an interrupt handler.
-put the sleeping thread on a channel waiting to be waken up
what function(s) handle(s) a context switch?
-switchframe_switch, when it gets called in thread_switch
What does it mean for a thread to be in each of the possible thread states?
-S_RUN : a thread that is currently running, such thread cannot be destroyed or waken
-S_Ready: a thread ready to run, can be add to the runque
-S_ZOMBIE: a thread put to sleep, cannot be run (should panic if ran), can be waken again to run
What does it mean to turn interrupts off? How is this accomplished? Why is it important to turn off interrupts in the thread subsystem code?
-In the event of a interrupt, the handler thread will not run to handle the event. 
-To turn off: spl = splhigh() 
-Its important to ensure that certain execution are done atomically. Disabling interrupt prevents another thread run while the current thread is executing a function.
What happens when a thread wakes up another thread? How does a sleeping thread get to run again?
-Removes the sleeping thread from the wait channel, and calls make_runnable and add the waken thread at the end of the runque. 
-When the waken thread is poped at the queue, it runs again when thread_switch is called.
What function(s) choose(s) the next thread to run?
-hardclock in kern/thread/clock.c 
-this function is called at a certain frequency, the frequency depends on the actual processor
-within this function thread_yield is called, then thread_yield calls thread_switch which then runs the thread next on the runque
How does it (do they) pick the next thread?
-they do not pick the next thread, rather they decide the time/frequency to switch to the next thread on the runque
What role does the hardware timer play in scheduling? What hardware independent function is called on a timer interrupt?
-it calls schedule() in thread.c every 4 hardclock cycle, so that the thread runque can be rescheduled based on job priority
Describe how wchan_sleep() and wchan_wakeone() are used to implement semaphores.
-semaphore calls wchan_sleep when the lock is not free
-after semaphore_td is V()'d, the thread that V()'d it wchan_wakeone() thread on the wchan
How does the implementation of wchan ensure that a thread never misses a wakeup signal: that another thread cannot attempt to awaken the first thread just as it is preparing to sleep, but before it is actually placed into the sleep queue?
-the thread preparing to sleep is first set to S_ZOMBIE,at such state it can not be set to recieve interrupt. If it ever runs at that state , it will issue a panic. 
